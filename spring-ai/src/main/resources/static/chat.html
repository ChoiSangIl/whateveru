<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ollama(Qwen) Chat Test</title>
    <style>
        body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; background:#0b0f19; color:#e6e8ee; }
        .wrap { max-width: 900px; margin:0 auto; padding:24px; }
        .card { background:#11182a; border:1px solid #223055; border-radius:16px; padding:16px; box-shadow:0 8px 30px rgba(0,0,0,.25); }
        textarea { width:100%; min-height:90px; resize:vertical; padding:12px; border-radius:12px; border:1px solid #2b3b66; background:#0c1222; color:#e6e8ee; }
        button { padding:10px 14px; border-radius:12px; border:1px solid #2b3b66; background:#182446; color:#e6e8ee; cursor:pointer; }
        button:disabled { opacity:.6; cursor:not-allowed; }
        pre { white-space: pre-wrap; word-break: break-word; margin:0; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:13px; line-height:1.5; }
        .row { display:flex; gap:12px; flex-wrap:wrap; margin-top:12px; }
        .hint { color:#aab3c7; font-size:12px; margin-top:10px; }
        .error { color:#ffb4b4; }
        code { background:#0c1222; padding:2px 6px; border-radius:8px; border:1px solid #2b3b66; }
    </style>
</head>
<body>
<div class="wrap">
    <h2 style="margin:0 0 14px 0;">Ollama(Qwen) Chat Test</h2>

    <div class="card" style="margin-bottom:14px;">
        <label for="msg" style="display:block; margin-bottom:8px;">질문</label>
        <textarea id="msg" placeholder="예) 한국어로 자연스럽게 대답해줘. Spring AI에서 Ollama 쓰는 법 알려줘"></textarea>

        <div class="row">
            <button id="btnOnce">일반 요청</button>
            <button id="btnStream">스트리밍 요청(SSE)</button>
            <button id="btnStop" disabled>스트리밍 중단</button>
            <button id="btnClear" type="button">지우기</button>
        </div>

        <div class="hint">
            엔드포인트: <code>POST /api/chat</code>, <code>POST /api/chat/stream</code>
            <span id="status" style="margin-left:10px;"></span>
        </div>
    </div>

    <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; margin-bottom:10px;">
            <strong>답변</strong>
            <span class="hint">SSE는 <code>data:</code> 라인만 파싱해서 실시간으로 붙입니다.</span>
        </div>
        <pre id="out">답변이 여기에 표시됩니다.</pre>
        <div id="err" class="hint error" style="margin-top:10px;"></div>
    </div>
</div>

<script>
    const $ = (s) => document.querySelector(s);

    const out = $("#out");
    const err = $("#err");
    const status = $("#status");
    const msg = $("#msg");

    const btnOnce = $("#btnOnce");
    const btnStream = $("#btnStream");
    const btnStop = $("#btnStop");
    const btnClear = $("#btnClear");

    let abortController = null;

    function setBusy(busy) {
        btnOnce.disabled = busy;
        btnStream.disabled = busy;
        btnStop.disabled = !busy;
        status.textContent = busy ? "요청 중..." : "";
    }
    function setOutput(text) { out.textContent = text || ""; }
    function setError(text) { err.textContent = text || ""; }

    btnClear.addEventListener("click", () => {
        msg.value = "";
        setOutput("답변이 여기에 표시됩니다.");
        setError("");
    });

    btnStop.addEventListener("click", () => {
        if (abortController) abortController.abort();
    });

    // 일반 요청: POST /api/chat  { message } -> { answer }
    btnOnce.addEventListener("click", async () => {
        setError("");
        setOutput("");
        const message = msg.value.trim();
        if (!message) return setError("질문을 입력해 주세요.");

        try {
            setBusy(true);
            const res = await fetch("/api/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ message })
            });

            const ct = res.headers.get("content-type") || "";
            if (!res.ok) {
                const body = await res.text().catch(() => "");
                throw new Error(`HTTP ${res.status} ${res.statusText}\n${body}`);
            }

            if (ct.includes("application/json")) {
                const data = await res.json();
                setOutput(data.answer ?? JSON.stringify(data, null, 2));
            } else {
                setOutput(await res.text());
            }
        } catch (e) {
            setError(String(e));
        } finally {
            setBusy(false);
        }
    });

    // 스트리밍 요청: POST /api/chat/stream (TEXT_EVENT_STREAM)
    // SSE는 "data: ...\n\n" 형태라 data 라인만 파싱해서 붙임
    btnStream.addEventListener("click", async () => {
        setError("");
        setOutput("");
        const message = msg.value.trim();
        if (!message) return setError("질문을 입력해 주세요.");

        abortController = new AbortController();

        try {
            setBusy(true);

            const res = await fetch("/api/chat/stream", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ message }),
                signal: abortController.signal
            });

            if (!res.ok) {
                const body = await res.text().catch(() => "");
                throw new Error(`HTTP ${res.status} ${res.statusText}\n${body}`);
            }
            if (!res.body) throw new Error("ReadableStream을 사용할 수 없습니다. 브라우저를 확인해 주세요.");

            const reader = res.body.getReader();
            const decoder = new TextDecoder("utf-8");

            let buffer = "";
            let assembled = "";

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });

                // 이벤트 구분은 \n\n
                const events = buffer.split("\n\n");
                buffer = events.pop() ?? "";

                for (const evt of events) {
                    const dataLines = evt
                        .split("\n")
                        .filter(line => line.startsWith("data:"))
                        .map(line => line.replace(/^data:\s?/, ""));

                    if (dataLines.length === 0) continue;

                    assembled += dataLines.join("\n");
                    setOutput(assembled);
                }
            }

            // SSE가 아닌 일반 텍스트 스트림이면 남은 버퍼 표시
            if (!assembled && buffer.trim()) setOutput(buffer);

        } catch (e) {
            if (String(e).includes("AbortError")) {
                setError("스트리밍을 중단했습니다.");
            } else {
                setError(String(e));
            }
        } finally {
            abortController = null;
            setBusy(false);
        }
    });
</script>
</body>
</html>
